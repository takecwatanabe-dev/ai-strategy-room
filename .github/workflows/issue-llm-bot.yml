name: Issue LLM Bot

on:
  issues:
    types: [opened, reopened]

permissions:
  contents: read
  issues: write

jobs:
  task_auto_reply:
    if: startsWith(github.event.issue.title, '[TASK]')
    runs-on: ubuntu-latest
    steps:
      - name: Post auto reply (TASK)
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_MODEL: gpt-5-mini
          BOT_VERSION: v1.2.0
          BOT_BUILD: 2025-12-14_1718_thumb-details-r1
        with:
          script: |
            const issue = context.payload.issue;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const apiKey = (process.env.OPENAI_API_KEY || '').trim();
            const model = (process.env.OPENAI_MODEL || 'gpt-5-mini').trim();
            const BOT_VERSION = process.env.BOT_VERSION || 'v?.?.?';
            const BOT_BUILD = process.env.BOT_BUILD || '';

            const MARKER = '<!-- ISSUE_LLM_BOT_TASK -->';

            function stripNoResponse(s) {
              if (!s) return '';
              return String(s).replace(/\r/g, '').replace(/\bNo response\b/gi, '').trim();
            }

            function extractImageUrls(text) {
              const urls = new Set();
              if (!text) return [];

              const t = String(text);

              // GitHubè²¼ã‚Šä»˜ã‘ã® <img ... src="...">
              const srcRe = /<img[^>]+src="([^"]+)"[^>]*\/?>/gi;
              let m;
              while ((m = srcRe.exec(t)) !== null) {
                if (m[1]) urls.add(m[1]);
              }

              // Markdown ![alt](url)
              const mdRe = /!\[[^\]]*]\(([^)]+)\)/g;
              while ((m = mdRe.exec(t)) !== null) {
                const u = (m[1] || '').split(/\s+/)[0];
                if (u) urls.add(u);
              }

              // URLç›´æ›¸ãï¼ˆå¿µã®ãŸã‚ï¼‰
              const urlRe = /(https?:\/\/[^\s)]+github\.com\/user-attachments\/assets\/[^\s)]+|https?:\/\/private-user-images\.githubusercontent\.com\/[^\s)]+)/g;
              while ((m = urlRe.exec(t)) !== null) {
                if (m[0]) urls.add(m[0]);
              }

              return Array.from(urls);
            }

            function buildImagePreview(urls) {
              if (!urls || urls.length === 0) return '';

              const THUMB_W = 220;   // ã‚µãƒ ãƒï¼ˆå¸¸æ™‚è¡¨ç¤ºï¼‰
              const FULL_W  = 960;   // å¤§ãã‚è¡¨ç¤ºï¼ˆdetailså†…ï¼‰

              const thumbs = urls.map((u, i) =>
                `<img src="${u}" width="${THUMB_W}" alt="thumb-${i + 1}">`
              ).join('\n');

              const fulls = urls.map((u, i) =>
                `<p><img src="${u}" width="${FULL_W}" alt="full-${i + 1}"></p>`
              ).join('\n');

              return [
                '',
                '---',
                '## æ·»ä»˜ç”»åƒï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰',
                '',
                // â˜…ã“ã“ãŒãƒã‚¤ãƒ³ãƒˆï¼šæŠ˜ã‚ŠãŸãŸã¿ã®å¤–ã«ã‚µãƒ ãƒã‚’å‡ºã™ï¼ˆé–‰ã˜ã¦ã¦ã‚‚è¦‹ãˆã‚‹ï¼‰
                '<p>',
                thumbs,
                '</p>',
                '',
                '<details>',
                '  <summary>ğŸ–¼ å¤§ãã‚è¡¨ç¤ºï¼ˆã‚¯ãƒªãƒƒã‚¯ã§é–‹ãï¼ã‚‚ã†ä¸€åº¦ã§é–‰ã˜ã‚‹ï¼‰</summary>',
                `  ${fulls.replace(/\n/g, '\n  ')}`,
                '</details>',
                ''
              ].join('\n');
            }

            async function callOpenAI({ title, body }) {
              // ç”»åƒã‚¿ã‚°ã¯å¾Œæ®µã§ç¢ºå®Ÿã«ä»˜ã‘ã‚‹ã®ã§ã€AIã«ã¯å‡ºã•ã›ãªã„
              const systemText = [
                'ã‚ãªãŸã¯ GitHub Issue ã®è‡ªå‹•è¿”ä¿¡ãƒœãƒƒãƒˆã§ã™ã€‚',
                'å‡ºåŠ›ã¯ã€ŒGitHub Markdownã®ã¿ã€ã€‚',
                'å¿…ãšæ¬¡ã®è¦‹å‡ºã—ã‚’ã“ã®é †ã§å‡ºã—ã¦ãã ã•ã„ï¼š',
                '## è¦æ—¨',
                '## æ¬¡ã®1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆ1ã¤ã ã‘ï¼‰',
                '## æ‰‹é †ï¼ˆStep 1â†’ï¼‰',
                '## ã†ã¾ãã„ã‹ãªã„æ™‚',
                '## æ³¨æ„ç‚¹',
                '',
                'åˆ¶ç´„ï¼š',
                '- ç”»åƒã®HTML/Markdownã¯å‡ºã•ãªã„ï¼ˆç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¯åˆ¥ã§ä»˜ã‘ã¾ã™ï¼‰',
                '- Secretsåã¯ OPENAI_API_KEY ã®ã¿ï¼ˆPENAI_API_KEY ãªã©ã¯å‡ºã•ãªã„ï¼‰',
                '- 1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ–¹å¼ã§ã€Stepã¯çŸ­ã'
              ].join('\n');

              const userText = [
                `Issueã‚¿ã‚¤ãƒˆãƒ«: ${title}`,
                '',
                'Issueæœ¬æ–‡:',
                body || '(æœ¬æ–‡ãªã—)',
                '',
                'çŠ¶æ³ï¼šæœ¬æ–‡ãŒè–„ã„/ç©ºã®å ´åˆã¯ã€åŸ‹ã‚ã‚‹ã¹ãæœ€å°æƒ…å ±ã‚’ã€Œæ¬¡ã®1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã€ã«1ã¤ã ã‘æç¤ºã—ã¦ãã ã•ã„ã€‚'
              ].join('\n');

              const payload = {
                model,
                input: [
                  { role: 'system', content: [{ type: 'text', text: systemText }] },
                  { role: 'user', content: [{ type: 'text', text: userText }] }
                ],
                max_output_tokens: 700,
                temperature: 0.2
              };

              const res = await fetch('https://api.openai.com/v1/responses', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify(payload)
              });

              if (!res.ok) {
                const errText = await res.text().catch(() => '');
                throw new Error(`OpenAI API error: ${res.status} ${res.statusText} ${errText}`.slice(0, 4000));
              }

              const data = await res.json();

              // ã§ãã‚‹ã ã‘å£Šã‚Œã«ããå–ã‚Šå‡ºã™
              if (data && typeof data.output_text === 'string' && data.output_text.trim()) {
                return data.output_text.trim();
              }

              // fallbackï¼ˆæ§‹é€ æ¢ç´¢ï¼‰
              const out = data?.output || [];
              for (const block of out) {
                const content = block?.content || [];
                for (const c of content) {
                  const t = c?.text;
                  if (typeof t === 'string' && t.trim()) return t.trim();
                }
              }

              return '';
            }

            async function upsertBotComment(finalBody) {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner, repo, issue_number: issue.number, per_page: 100
              });

              const existing = comments.find(c =>
                c?.body && c.body.includes(MARKER) && c?.user?.login === 'github-actions[bot]'
              );

              const bodyWithMarker = `${MARKER}\n${finalBody}`;

              if (existing) {
                await github.rest.issues.updateComment({
                  owner, repo,
                  comment_id: existing.id,
                  body: bodyWithMarker
                });
              } else {
                await github.rest.issues.createComment({
                  owner, repo,
                  issue_number: issue.number,
                  body: bodyWithMarker
                });
              }
            }

            const rawBody = issue.body || '';
            const body = stripNoResponse(rawBody);
            const imageUrls = extractImageUrls(rawBody);
            const imagePreview = buildImagePreview(imageUrls);

            let mainText = '';
            if (!apiKey) {
              // APIã‚­ãƒ¼ç„¡ã—ã§ã‚‚ã€Œç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€ã¯å‡ºã™
              mainText = [
                '## è¦æ—¨',
                'Botå´ã§AIå‘¼ã³å‡ºã—ãŒã§ãã¾ã›ã‚“ï¼ˆOPENAI_API_KEY æœªè¨­å®šï¼‰ã€‚',
                '',
                '## æ¬¡ã®1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆ1ã¤ã ã‘ï¼‰',
                '`Settings â†’ Secrets and variables â†’ Actions` ã« `OPENAI_API_KEY` ã‚’å…¥ã‚Œã¦ã€Issueã‚’ã€ŒCloseâ†’Reopenã€ã—ã¦ãã ã•ã„ã€‚',
                '',
                '## æ‰‹é †ï¼ˆStep 1â†’ï¼‰',
                'Step 1ï¼š`OPENAI_API_KEY` ã‚’ç™»éŒ²',
                'Step 2ï¼šã“ã®Issueã‚’ Closeâ†’Reopen',
                '',
                '## ã†ã¾ãã„ã‹ãªã„æ™‚',
                '- Secretåã®ã‚¹ãƒšãƒ«ï¼ˆOPENAI_API_KEYï¼‰ã‚’ç¢ºèª',
                '',
                '## æ³¨æ„ç‚¹',
                '- APIã‚­ãƒ¼æœ¬ä½“ã¯Issueæœ¬æ–‡ã‚„ã‚³ãƒ¡ãƒ³ãƒˆã«è²¼ã‚‰ãªã„ã§ãã ã•ã„ã€‚',
                '',
                `build: ${BOT_BUILD} / ${BOT_VERSION}`
              ].join('\n');
            } else {
              try {
                const ai = await callOpenAI({ title: issue.title, body });
                mainText = ai || [
                  '## è¦æ—¨',
                  'è‡ªå‹•è¦ç´„ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆç©ºã®å¿œç­”ï¼‰ã€‚',
                  '',
                  '## æ¬¡ã®1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆ1ã¤ã ã‘ï¼‰',
                  'ã€Œç›®çš„ï¼ˆ1è¡Œï¼‰ã€ã«ã€èª°ãŒä½•ã‚’ã„ã¤ã¾ã§ã«ã‚„ã‚‹ã‹ã‚’1æ–‡ã§è¿½è¨˜ã—ã¦ãã ã•ã„ã€‚',
                  '',
                  '## æ‰‹é †ï¼ˆStep 1â†’ï¼‰',
                  'Step 1ï¼šã‚³ãƒ¡ãƒ³ãƒˆã§ç›®çš„ã‚’1è¡Œè¿½è¨˜',
                  '',
                  '## ã†ã¾ãã„ã‹ãªã„æ™‚',
                  '- Issueæœ¬æ–‡ãŒç©ºã ã¨åˆ¤æ–­ææ–™ãŒä¸è¶³ã—ã¾ã™',
                  '',
                  '## æ³¨æ„ç‚¹',
                  '- APIã‚­ãƒ¼æœ¬ä½“ã¯è²¼ã‚‰ãªã„',
                  '',
                  `build: ${BOT_BUILD} / ${BOT_VERSION}`
                ].join('\n');
              } catch (e) {
                mainText = [
                  '## è¦æ—¨',
                  'Botå´ã§AIå‘¼ã³å‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚',
                  '',
                  '## æ¬¡ã®1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆ1ã¤ã ã‘ï¼‰',
                  'Actionsã®å®Ÿè¡Œãƒ­ã‚°ã‚’é–‹ã„ã¦ã€ã„ã¡ã°ã‚“ä¸‹ã®èµ¤ã„ã‚¨ãƒ©ãƒ¼è¡Œã‚’ã“ã®Issueã«è²¼ã£ã¦ãã ã•ã„ã€‚',
                  '',
                  '## æ‰‹é †ï¼ˆStep 1â†’ï¼‰',
                  'Step 1ï¼šActions â†’ è©²å½“Run â†’ Logs ã‚’é–‹ã',
                  'Step 2ï¼šèµ¤ã„è¡Œã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ã‚³ãƒ¡ãƒ³ãƒˆ',
                  '',
                  '## ã†ã¾ãã„ã‹ãªã„æ™‚',
                  '- OPENAI_API_KEY ãŒå…¥ã£ã¦ã„ã‚‹ã‹å†ç¢ºèª',
                  '',
                  '## æ³¨æ„ç‚¹',
                  '- APIã‚­ãƒ¼æœ¬ä½“ã¯è²¼ã‚‰ãªã„',
                  '',
                  `build: ${BOT_BUILD} / ${BOT_VERSION}`,
                  '',
                  `ï¼ˆå†…éƒ¨ã‚¨ãƒ©ãƒ¼è¦ç´„ï¼‰${String(e?.message || e).slice(0, 240)}`
                ].join('\n');
              }
            }

            const finalBody = `${mainText}\n${imagePreview}`;
            await upsertBotComment(finalBody);
