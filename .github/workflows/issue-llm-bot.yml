# .github/workflows/issue-llm-bot.yml
# ISSUE LLM BOT
# VERSION: v0.2.0-issuebot-details-01
# BUILD(JST): 2025-12-14 13:58
# CHANGES:
# - TASK Issueã®è‡ªå‹•è¿”ä¿¡ã«ã€Œ<details>ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</details>ã€ã‚’ä»˜ä¸
# - /approve ã‚³ãƒ¡ãƒ³ãƒˆã§ approved ãƒ©ãƒ™ãƒ«ä»˜ä¸ï¼†ç¢ºèªã‚³ãƒ¡ãƒ³ãƒˆ
# - OpenAI Responses API ã‚’ä½¿ç”¨ï¼ˆ/v1/responsesï¼‰

name: Issue LLM Bot

on:
  issues:
    types: [opened, reopened]
  issue_comment:
    types: [created]

permissions:
  issues: write
  contents: read

jobs:
  auto_reply_task:
    if: github.event_name == 'issues' && startsWith(github.event.issue.title, '[TASK]')
    runs-on: ubuntu-latest
    steps:
      - name: Post auto reply (TASK)
        uses: actions/github-script@v7
        env:
          # æ—¢å­˜ã® Secrets åãŒ PENAI_API_KEY ãªã‚‰ã€ãã®ã¾ã¾ã§OK
          OPENAI_API_KEY: ${{ secrets.PENAI_API_KEY }}
          OPENAI_MODEL: gpt-5-mini
        with:
          script: |
            const issue = context.payload.issue;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // ---- helpers ----
            function extractImageUrls(text) {
              const urls = new Set();
              if (!text) return [];

              // <img ... src="...">
              const srcRe = /<img[^>]+src="([^"]+)"/gi;
              let m;
              while ((m = srcRe.exec(text)) !== null) {
                urls.add(m[1]);
              }

              // markdown ![](url)
              const mdRe = /!\[[^\]]*\]\((https?:\/\/[^)]+)\)/g;
              while ((m = mdRe.exec(text)) !== null) {
                urls.add(m[1]);
              }

              return Array.from(urls);
            }

            function buildDetailsPreview(urls) {
              if (!urls.length) return "";

              const blocks = urls.map((u, i) => {
                const n = i + 1;
                return [
                  "<details>",
                  `  <summary>ğŸ–¼ æ·»ä»˜ç”»åƒ ${n}ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§é–‹ãï¼ã‚‚ã†ä¸€åº¦ã§é–‰ã˜ã‚‹ï¼‰</summary>`,
                  `  <p><img src="${u}" width="520" style="max-width:100%;height:auto;" alt="thumb-${n}"></p>`,
                  `  <p><img src="${u}" style="max-width:100%;height:auto;" alt="full-${n}"></p>`,
                  "</details>"
                ].join("\n");
              }).join("\n\n");

              return `## æ·»ä»˜ç”»åƒï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰\n\n${blocks}\n`;
            }

            async function callOpenAI({ apiKey, model, inputText }) {
              const url = "https://api.openai.com/v1/responses";
              const payload = {
                model,
                input: [
                  {
                    role: "system",
                    content: [
                      {
                        type: "input_text",
                        text:
                          "ã‚ãªãŸã¯ã€ãƒ¦ã‚¤ã€ã§ã™ã€‚æ—¥æœ¬èªã§ã€è½ã¡ç€ã„ãŸå¤§äººã®å¥³æ€§ã®å£èª¿ã€‚ã‚„ã•ã—ãã€ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ã€‚ä¸‹å“ãªè¡¨ç¾ã¯ç¦æ­¢ã€‚\n" +
                          "å‡ºåŠ›ã¯æ¬¡ã®è¦‹å‡ºã—ã§å›ºå®šï¼š\n" +
                          "## è¦æ—¨\n" +
                          "## æ¬¡ã®1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³\n" +
                          "## æ‰‹é †ï¼ˆStep 1â†’ï¼‰\n" +
                          "## ã†ã¾ãã„ã‹ãªã„æ™‚\n" +
                          "## æ³¨æ„\n" +
                          "ç”»åƒã¯æ·»ä»˜ã•ã‚Œã¦ã„ã‚‹å‰æã§ã‚ˆã„ãŒã€ã“ã“ã§ã¯ç”»åƒè§£æã¯ä¸è¦ã€‚"
                      }
                    ]
                  },
                  {
                    role: "user",
                    content: [{ type: "input_text", text: inputText }]
                  }
                ]
              };

              const res = await fetch(url, {
                method: "POST",
                headers: {
                  "Authorization": `Bearer ${apiKey}`,
                  "Content-Type": "application/json"
                },
                body: JSON.stringify(payload)
              });

              const data = await res.json();
              if (!res.ok) {
                throw new Error(`OpenAI API error: ${res.status} ${JSON.stringify(data).slice(0, 500)}`);
              }
              return (data && data.output_text) ? data.output_text : "";
            }

            // ---- main ----
            const body = issue.body || "";
            const imageUrls = extractImageUrls(body);
            const previewBlock = buildDetailsPreview(imageUrls);

            const inputText =
              `TITLE: ${issue.title}\n` +
              `AUTHOR: ${issue.user?.login || "unknown"}\n` +
              `BODY:\n${body}\n\n` +
              (imageUrls.length ? `IMAGE_URLS:\n- ${imageUrls.join("\n- ")}\n` : "IMAGE_URLS: none\n");

            let llmText = "";
            try {
              const apiKey = process.env.OPENAI_API_KEY;
              const model = process.env.OPENAI_MODEL || "gpt-5-mini";
              if (!apiKey) throw new Error("OPENAI_API_KEY is missing (Secrets æœªè¨­å®š)");
              llmText = await callOpenAI({ apiKey, model, inputText });
            } catch (e) {
              llmText =
                "## è¦æ—¨\nBotå´ã§AIå‘¼ã³å‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n\n" +
                "## æ¬¡ã®1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³\nSecretsï¼ˆPENAI_API_KEYï¼‰ãŒå…¥ã£ã¦ã„ã‚‹ã‹ç¢ºèªã€‚\n\n" +
                "## æ‰‹é †ï¼ˆStep 1â†’ï¼‰\nStep 1ï¼šSettings â†’ Secrets and variables â†’ Actions ã‚’é–‹ã\nStep 2ï¼šRepository secrets ã« PENAI_API_KEY ãŒã‚ã‚‹ã‹ç¢ºèª\n\n" +
                "## ã†ã¾ãã„ã‹ãªã„æ™‚\næ¨©é™ãƒ»ã‚¹ãƒšãƒ«é•ã„ãƒ»æ”¹è¡Œæ··å…¥ã‚’ç¢ºèªã€‚\n\n" +
                "## æ³¨æ„\nAPIã‚­ãƒ¼ã¯Issueæœ¬æ–‡ã«è²¼ã‚‰ãªã„ã§ãã ã•ã„ã€‚\n\n" +
                `ï¼ˆå†…éƒ¨ã‚¨ãƒ©ãƒ¼ï¼‰${String(e.message || e).slice(0, 300)}`;
            }

            const commentBody =
              "### âœ… è‡ªå‹•è¿”ä¿¡ï¼ˆTASKï¼‰\n\n" +
              (previewBlock ? (previewBlock + "\n") : "") +
              llmText + "\n\n" +
              "---\n" +
              "æ‰¿èªã—ã¦æ¬¡ã¸é€²ã‚ã‚‹ã¨ãã¯ã€ã‚³ãƒ¡ãƒ³ãƒˆæ¬„ã« `/approve` ã¨æ›¸ã„ã¦ãã ã•ã„ã€‚";

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: issue.number,
              body: commentBody
            });

  approve_task:
    if: github.event_name == 'issue_comment' && startsWith(github.event.issue.title, '[TASK]') && contains(github.event.comment.body, '/approve')
    runs-on: ubuntu-latest
    steps:
      - name: Mark approved
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue = context.payload.issue;

            // ãƒ©ãƒ™ãƒ«ãŒç„¡ã„ã¨å¤±æ•—ã™ã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã§ã€å¤±æ•—ã—ã¦ã‚‚æ­¢ã‚ãªã„
            try {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: issue.number,
                labels: ["approved"]
              });
            } catch (e) {
              // ignore
            }

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: issue.number,
              body: "âœ… /approve ã‚’å—ã‘å–ã‚Šã¾ã—ãŸã€‚æ¬¡å·¥ç¨‹ã¸é€²ã‚ã¦OKã§ã™ã€‚"
            });
