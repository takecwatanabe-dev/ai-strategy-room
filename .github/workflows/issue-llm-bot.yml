# Issue LLM Bot (TASK)
# VERSION: v1.2.1
# BUILD(JST): 2025-12-14 18:37
# CHANGES:
#  - Secrets参照を OPENAI_API_KEY のみに統一（PENAI_* は完全撤去）
#  - OpenAI Responses API の content type を input_text / input_image に修正（400: invalid value 'text' を解消）
#  - 画像は「サムネを常時表示」＋「<details>で拡大」に統一
#  - Issue本文内の巨大画像（![](...)）も自動でサムネ＋拡大に置換（読みにくさ対策）

name: Issue LLM Bot

on:
  issues:
    types: [opened, reopened]

permissions:
  issues: write
  contents: read

jobs:
  task_auto_reply:
    if: startsWith(github.event.issue.title, '[TASK]')
    runs-on: ubuntu-latest
    steps:
      - name: Post auto reply (TASK)
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_MODEL: gpt-5-mini
          BOT_VERSION: v1.2.1
          BOT_BUILD: 2025-12-14_1837_thumb-details-r2
        with:
          script: |
            const issue = context.payload.issue;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const BUILD = process.env.BOT_BUILD || "unknown_build";
            const VERSION = process.env.BOT_VERSION || "unknown_version";

            function extractImageUrls(text) {
              if (!text) return [];
              const urls = new Set();

              // Markdown image: ![alt](url)
              const mdImg = /!\[[^\]]*\]\((https?:\/\/[^\s)]+)\)/g;
              let m;
              while ((m = mdImg.exec(text)) !== null) urls.add(m[1]);

              // HTML img: <img src="...">
              const htmlImg = /<img[^>]+src=["']([^"']+)["']/gi;
              while ((m = htmlImg.exec(text)) !== null) urls.add(m[1]);

              return Array.from(urls);
            }

            function stripImages(text) {
              if (!text) return "";
              // remove markdown images
              let t = text.replace(/!\[[^\]]*\]\((https?:\/\/[^\s)]+)\)/g, "");
              // keep html but remove img tags
              t = t.replace(/<img[^>]*>/gi, "");
              return t.trim();
            }

            function thumbBlock(url, i) {
              const n = i + 1;
              const safeUrl = String(url).replace(/"/g, "&quot;");
              return [
                `<img src="${safeUrl}" width="360" />`,
                ``,
                `<details>`,
                `<summary>大きく表示（画像${n}）</summary>`,
                ``,
                `<img src="${safeUrl}" />`,
                `</details>`
              ].join("\n");
            }

            function transformIssueBodyToThumbs(body) {
              if (!body) return body;
              // 二重変換防止
              if (body.includes("<!-- thumb-details-v1 -->")) return body;

              const re = /!\[[^\]]*\]\((https?:\/\/[^\s)]+)\)/g;
              let found = false;
              let idx = 0;

              const replaced = body.replace(re, (_all, url) => {
                found = true;
                const block = thumbBlock(url, idx);
                idx += 1;
                return block;
              });

              if (!found) return body;
              return `<!-- thumb-details-v1 -->\n${replaced}`;
            }

            function pickOutputText(data) {
              if (!data) return "";
              if (typeof data.output_text === "string" && data.output_text.trim()) return data.output_text.trim();

              // Fallback: walk output array
              const out = [];
              const arr = Array.isArray(data.output) ? data.output : [];
              for (const item of arr) {
                const c = Array.isArray(item.content) ? item.content : [];
                for (const part of c) {
                  if (part && typeof part.text === "string") out.push(part.text);
                  if (part && typeof part.output_text === "string") out.push(part.output_text);
                }
              }
              return out.join("\n").trim();
            }

            async function callOpenAI({ title, bodyText, imageUrls }) {
              const apiKey = (process.env.OPENAI_API_KEY || "").trim();
              if (!apiKey) {
                throw new Error("OPENAI_API_KEY is missing (Secrets 未設定)");
              }

              const model = (process.env.OPENAI_MODEL || "gpt-5-mini").trim();

              const content = [];
              content.push({
                type: "input_text",
                text:
                  [
                    "あなたはGitHub IssueのTASK受付ボットです。",
                    "出力は日本語。長文になりすぎないように、要点中心。",
                    "",
                    "必ずこの順で書く：",
                    "1) 要旨（2〜4行）",
                    "2) 次の1アクション（1つだけ）",
                    "3) 手順（Step 1→）",
                    "4) うまくいかない時（短く）",
                    "5) 注意（APIキー等は貼らない）",
                    "",
                    "【Issue情報】",
                    `タイトル: ${title}`,
                    "本文:",
                    bodyText || "(本文なし)",
                    imageUrls?.length ? `\n添付画像URL数: ${imageUrls.length}` : ""
                  ].join("\n")
              });

              const maxImages = 4;
              const imgs = Array.isArray(imageUrls) ? imageUrls.slice(0, maxImages) : [];
              for (const url of imgs) {
                content.push({ type: "input_image", image_url: url });
              }

              const payload = {
                model,
                input: [
                  {
                    role: "user",
                    content
                  }
                ],
                max_output_tokens: 900
              };

              const res = await fetch("https://api.openai.com/v1/responses", {
                method: "POST",
                headers: {
                  "Authorization": `Bearer ${apiKey}`,
                  "Content-Type": "application/json"
                },
                body: JSON.stringify(payload)
              });

              const data = await res.json().catch(() => ({}));
              if (!res.ok) {
                const msg = data?.error?.message || `${res.status} ${res.statusText}`;
                throw new Error(`OpenAI API error: ${msg}`);
              }

              return pickOutputText(data) || "（AIの出力が空でした）";
            }

            function buildComment({ aiText, imageUrls }) {
              const imgs = Array.isArray(imageUrls) ? imageUrls : [];
              const thumbSection = imgs.length
                ? [
                    "## 添付画像（サムネ）",
                    ...imgs.map((u, i) => thumbBlock(u, i))
                  ].join("\n\n")
                : "";

              return [
                "## Bot返信（TASK）",
                "",
                `build: ${BUILD} / ${VERSION}`,
                "",
                aiText,
                "",
                thumbSection,
                "",
                "承認して次へ進めるときは、コメント欄に **/approve** と書いてください。"
              ].filter(Boolean).join("\n");
            }

            // ---- main ----
            const issueNumber = issue.number;
            const rawBody = issue.body || "";
            const imageUrls = extractImageUrls(rawBody);

            // 1) Issue本文の巨大画像をサムネ化（希望仕様）
            try {
              const newBody = transformIssueBodyToThumbs(rawBody);
              if (newBody !== rawBody) {
                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  body: newBody
                });
              }
            } catch (e) {
              // 本文変換に失敗しても、BOT返信自体は続行
            }

            // 2) AI呼び出し（失敗してもコメントは必ず出す）
            let aiText = "";
            try {
              const clean = stripImages(rawBody);
              aiText = await callOpenAI({
                title: issue.title || "",
                bodyText: clean.slice(0, 12000),
                imageUrls
              });
            } catch (e) {
              aiText = `（内部エラー）${e?.message || String(e)}`;
            }

            // 3) 返信コメント投稿
            const commentBody = buildComment({ aiText, imageUrls });
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: issueNumber,
              body: commentBody
            });
