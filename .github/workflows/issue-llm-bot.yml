# =========================================================
# ISSUE LLM BOT WORKFLOW
# Version: v0.3.0
# Build(JST): 2025-12-14 11:23
# File: .github/workflows/issue-llm-bot.yml
#
# ç›®çš„:
# - [TASK] Issue ã® opened/reopened ã§ Bot ãŒè¦æ—¨/æ¬¡ã®1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿”ã™
# - ç”»åƒãƒªãƒ³ã‚¯ã‚’ã€Œåˆ¥ã‚¿ãƒ–ã‚’é–‹ã‹ãªã„ã€HTML <img> ã§ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤ºã™ã‚‹
# - /approve ã‚³ãƒ¡ãƒ³ãƒˆã‚’å—ã‘ã¦æ‰¿èªå—ä»˜ã‚’è¿”ã™ï¼ˆå°†æ¥ Rex é€£æºã®èµ·ç‚¹ï¼‰
#
# å¿…è¦(ã©ã¡ã‚‰ã‹ä¸€æ–¹ã§OK):
# - Secrets: GEMINI_API_KEY  (æ¨å¥¨)
# - Secrets: OPENAI_API_KEY  (ä»»æ„)
#
# ä»»æ„:
# - Variables: GEMINI_MODEL (ä¾‹: gemini-1.5-pro)
# - Variables: OPENAI_MODEL (ä¾‹: gpt-4o-mini ç­‰)
# =========================================================

name: Issue LLM Bot

on:
  issues:
    types: [opened, reopened]
  issue_comment:
    types: [created]
  workflow_dispatch: {}

permissions:
  contents: read
  issues: write

concurrency:
  group: issue-llm-bot-${{ github.repository }}-${{ github.event.issue.number || github.event.comment.issue_url }}
  cancel-in-progress: true

jobs:
  bot:
    runs-on: ubuntu-latest
    steps:
      - name: Run bot
        uses: actions/github-script@v7
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GEMINI_MODEL: ${{ vars.GEMINI_MODEL }}
          OPENAI_MODEL: ${{ vars.OPENAI_MODEL }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // -----------------------------
            // Helpers
            // -----------------------------
            const uniq = (arr) => Array.from(new Set(arr.filter(Boolean)));

            function pickLabelNames(labels) {
              if (!labels) return [];
              return labels.map(l => typeof l === 'string' ? l : l?.name).filter(Boolean);
            }

            function isTaskIssue(issue) {
              const title = (issue?.title || '').trim();
              const labels = pickLabelNames(issue?.labels || []);
              return title.startsWith('[TASK]') || labels.includes('task');
            }

            function extractImageUrls(text) {
              const body = text || '';
              const urls = [];

              // Markdown images: ![alt](url)
              const mdImg = /!\[[^\]]*\]\((https?:\/\/[^\s)]+)\)/g;
              for (const m of body.matchAll(mdImg)) urls.push(m[1]);

              // HTML images: <img src="url"...>
              const htmlImg = /<img[^>]*\ssrc="([^"]+)"[^>]*>/g;
              for (const m of body.matchAll(htmlImg)) urls.push(m[1]);

              // Raw urls (loose): include github attachments and common image extensions
              const raw = /(https?:\/\/[^\s<>"')]+(?:\.png|\.jpg|\.jpeg|\.gif|\.webp|githubusercontent\.com\/[^\s<>"')]+|github\.com\/user-attachments\/assets\/[^\s<>"')]+))/gi;
              for (const m of body.matchAll(raw)) urls.push(m[1]);

              // GitHub "private-user-images" domain
              const priv = /(https?:\/\/private-user-images\.githubusercontent\.com\/[^\s<>"')]+)/gi;
              for (const m of body.matchAll(priv)) urls.push(m[1]);

              return uniq(urls);
            }

            function buildImagePreviewBlock(imageUrls, max = 6) {
              const urls = (imageUrls || []).slice(0, max);
              if (urls.length === 0) return 'ï¼ˆæ·»ä»˜ç”»åƒãªã—ï¼‰';

              // NOTE:
              // - <img> ã ã‘ã§è¡¨ç¤ºï¼ˆãƒªãƒ³ã‚¯ã«ã—ãªã„ï¼‰â†’ ã‚¯ãƒªãƒƒã‚¯ã§åˆ¥ã‚¿ãƒ–ãŒé–‹ãã«ãã„
              // - <details> ã§ã€Œé–‹ã/é–‰ã˜ã‚‹ã€ã‚’å®Ÿç¾ï¼ˆâœ•ãƒœã‚¿ãƒ³ã®ä»£æ›¿ï¼‰
              // - width ã¯ thumb=520ã€full ã¯ max-width:100% ã§è‡ªå‹•ãƒ•ã‚£ãƒƒãƒˆ
              const blocks = urls.map((u, i) => {
                const n = i + 1;
                return [
                  `<details>`,
                  `  <summary>ğŸ–¼ æ·»ä»˜ç”»åƒ ${n}ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§é–‹ãï¼ã‚‚ã†ä¸€åº¦ã§é–‰ã˜ã‚‹ï¼‰</summary>`,
                  `  <p><img src="${u}" width="520" style="max-width:100%;height:auto;" alt="thumb-${n}"></p>`,
                  `  <p><img src="${u}" style="max-width:100%;height:auto;" alt="full-${n}"></p>`,
                  `</details>`
                ].join('\n');
              });

              return blocks.join('\n\n');
            }

            async function hasRecentBotComment(issue_number) {
              // ç›´è¿‘ã‚³ãƒ¡ãƒ³ãƒˆã«ãƒãƒ¼ã‚«ãƒ¼ãŒã‚ã‚‹ãªã‚‰é‡è¤‡æŠ•ç¨¿ã‚’é¿ã‘ã‚‹
              const { data } = await github.rest.issues.listComments({
                owner, repo, issue_number, per_page: 30,
              });
              return data.some(c => (c?.body || '').includes('<!-- ISSUE_LLM_BOT -->'));
            }

            async function postComment(issue_number, body) {
              await github.rest.issues.createComment({
                owner, repo, issue_number,
                body,
              });
            }

            async function callGemini(prompt) {
              const key = process.env.GEMINI_API_KEY;
              if (!key) return null;

              const model = process.env.GEMINI_MODEL || 'gemini-1.5-pro';
              const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${key}`;

              const payload = {
                contents: [
                  { role: "user", parts: [{ text: prompt }] }
                ],
                generationConfig: { temperature: 0.2 }
              };

              const res = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
              });

              if (!res.ok) {
                const t = await res.text().catch(() => '');
                core.warning(`Gemini API error: ${res.status} ${t}`);
                return null;
              }

              const json = await res.json();
              const text =
                json?.candidates?.[0]?.content?.parts?.map(p => p.text).filter(Boolean).join('\n') ||
                null;
              return text;
            }

            async function callOpenAI(prompt) {
              const key = process.env.OPENAI_API_KEY;
              if (!key) return null;

              // ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ/ãƒ¢ãƒ‡ãƒ«ã¯ç’°å¢ƒã§å·®ã—æ›¿ãˆã‚„ã™ãï¼ˆå›ºå®šã—ã™ããªã„ï¼‰
              const model = process.env.OPENAI_MODEL || 'gpt-4o-mini';
              const url = 'https://api.openai.com/v1/chat/completions';

              const payload = {
                model,
                messages: [
                  { role: 'system', content: 'ã‚ãªãŸã¯ã€ŒAIæˆ¦ç•¥ä¼šè­°å®¤ã€ã®æ•´ç†Botã§ã™ã€‚æ—¥æœ¬èªã§ã€çŸ­ãã€çµè«–â†’æ¬¡ã®1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®é †ã§æ›¸ã„ã¦ãã ã•ã„ã€‚' },
                  { role: 'user', content: prompt }
                ],
                temperature: 0.2
              };

              const res = await fetch(url, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${key}`,
                },
                body: JSON.stringify(payload),
              });

              if (!res.ok) {
                const t = await res.text().catch(() => '');
                core.warning(`OpenAI API error: ${res.status} ${t}`);
                return null;
              }

              const json = await res.json();
              const text = json?.choices?.[0]?.message?.content || null;
              return text;
            }

            function fallbackSummary(issue) {
              const title = issue?.title || '(no title)';
              return [
                `## è¦æ—¨`,
                `- ${title}`,
                ``,
                `## æ¬¡ã®1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³`,
                `- ç›®çš„ï¼ˆ1è¡Œï¼‰ã¨ã€ä¾é ¼å†…å®¹ï¼ˆã‚„ã‚ŠãŸã„ã“ã¨ï¼‰ã‚’ã‚‚ã†1æ®µã ã‘å…·ä½“åŒ–ã—ã¦æ›¸ã`,
                ``,
                `## ã†ã¾ãã„ã‹ãªã„æ™‚ã®åˆ†å²`,
                `A. ç›®çš„ãŒæ›–æ˜§ â†’ ã¾ãšã€Œä½•ã‚’æ±ºã‚ãŸã„ã‹ã€ã‚’1ã¤ã«çµã‚‹`,
                `B. æƒ…å ±ä¸è¶³ â†’ è¿½åŠ ã‚¹ã‚¯ã‚·ãƒ§/è¿½åŠ æ¡ä»¶ã‚’è¿½è¨˜ã™ã‚‹`,
                ``,
                `## æ³¨æ„ç‚¹`,
                `- ç§˜å¯†æƒ…å ±ï¼ˆAPIã‚­ãƒ¼ç­‰ï¼‰ã¯è²¼ã‚‰ãªã„`,
              ].join('\n');
            }

            // -----------------------------
            // Main dispatch
            // -----------------------------
            const eventName = context.eventName;

            // ---- /approve handler ----
            if (eventName === 'issue_comment') {
              const comment = context.payload.comment;
              const issue = context.payload.issue;
              const body = (comment?.body || '').trim();

              if (!issue || !isTaskIssue(issue)) {
                return; // TASKä»¥å¤–ã¯ç„¡è¦–
              }

              if (!body.includes('/approve')) {
                return; // approveä»¥å¤–ã¯ç„¡è¦–
              }

              const issue_number = issue.number;

              const ack = [
                `<!-- ISSUE_LLM_BOT -->`,
                `## æ‰¿èªã‚’å—ã‘å–ã‚Šã¾ã—ãŸ âœ…`,
                `- æ¬¡ã®å·¥ç¨‹ï¼ˆRexå¯¾å¿œï¼‰ã«é€²ã‚ã¦OKã§ã™ã€‚`,
                ``,
                `> ãƒ¡ãƒ¢ï¼šã“ã®å¾Œã®ã€ŒRexã¸è‡ªå‹•è»¢é€ã€ã¯ã€æ¬¡ã®æ”¹å–„ã§ç¹‹ã’ã‚„ã™ã„å½¢ã«ã—ã¦ã‚ã‚Šã¾ã™ã€‚`,
              ].join('\n');

              await postComment(issue_number, ack);
              return;
            }

            // ---- issues opened/reopened handler ----
            if (eventName === 'issues') {
              const issue = context.payload.issue;
              if (!issue || !isTaskIssue(issue)) return;

              const issue_number = issue.number;

              // é‡è¤‡é˜²æ­¢ï¼ˆç›´è¿‘ã«åŒãƒãƒ¼ã‚«ãƒ¼ãŒã‚ã‚Œã°æŠ•ç¨¿ã—ãªã„ï¼‰
              if (await hasRecentBotComment(issue_number)) return;

              const issueBody = issue.body || '';
              const imageUrls = extractImageUrls(issueBody);
              const preview = buildImagePreviewBlock(imageUrls, 6);

              const prompt = [
                `ã‚ãªãŸã¯ã€ŒAIæˆ¦ç•¥ä¼šè­°å®¤ã€ã®æ•´ç†Botã§ã™ã€‚`,
                `æ¬¡ã®Issueæœ¬æ–‡ã‚’èª­ã¿ã€ä»¥ä¸‹ã®è¦‹å‡ºã—ã§æ—¥æœ¬èªã§å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚`,
                ``,
                `ã€å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆå¿…é ˆï¼‰ã€‘`,
                `## è¦æ—¨`,
                `## æ¬¡ã®1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆ1ã¤ã ã‘ã€‚1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§ã§ãã‚‹å½¢ï¼‰`,
                `## ã†ã¾ãã„ã‹ãªã„æ™‚ã®åˆ†å²ï¼ˆA/Bï¼‰`,
                `## æ³¨æ„ç‚¹ï¼ˆçŸ­ãï¼‰`,
                ``,
                `ã€Issueã‚¿ã‚¤ãƒˆãƒ«ã€‘`,
                `${issue.title}`,
                ``,
                `ã€Issueæœ¬æ–‡ã€‘`,
                `${issueBody}`,
                ``,
                `â€»ç”»åƒã¯æœ¬æ–‡ä¸­ã«æ—¢ã«è²¼ã‚‰ã‚Œã¦ã„ã‚‹å‰æã§ã‚ˆã„ï¼ˆè§£æã¯ä¸è¦ï¼‰ã€‚`,
              ].join('\n');

              // 1) Geminiå„ªå…ˆ â†’ 2) OpenAI â†’ 3) fallback
              let text = await callGemini(prompt);
              if (!text) text = await callOpenAI(prompt);
              if (!text) text = fallbackSummary(issue);

              const finalComment = [
                `<!-- ISSUE_LLM_BOT -->`,
                `${text}`,
                ``,
                `## æ·»ä»˜ç”»åƒï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰`,
                preview,
              ].join('\n');

              await postComment(issue_number, finalComment);
              return;
            }

            // ãã®ä»–ã‚¤ãƒ™ãƒ³ãƒˆã¯ä½•ã‚‚ã—ãªã„
            return;
