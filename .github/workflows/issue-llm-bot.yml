# ISSUE LLM BOT — v1.2.2
# DATE(JST): 2025-12-14 19:17
# TITLE: Thumbify images in issue body + fix OpenAI content types
# CHANGES:
#  - Use only OPENAI_API_KEY (no PENAI_*)
#  - Auto-convert images in ISSUE BODY to thumbnail + details (md/img/raw url)
#  - Also run on "edited" (body change) but without posting a new bot reply
#  - Fix OpenAI Responses API content types: input_text / input_image
# BUILD PARAM: ?b=2025-12-14_1917_thumb-body-r2
# DEBUG: &debug=1 (optional)

name: Issue LLM Bot

on:
  issues:
    types: [opened, reopened, edited]

permissions:
  contents: read
  issues: write

jobs:
  llm_task:
    if: github.event_name == 'issues' && startsWith(github.event.issue.title, '[TASK]')
    runs-on: ubuntu-latest
    steps:
      - name: Post auto reply (TASK)
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_MODEL: gpt-5-mini
        with:
          script: |
            const issue = context.payload.issue;
            const action = context.payload.action;

            const apiKey = process.env.OPENAI_API_KEY || "";
            const model = process.env.OPENAI_MODEL || "gpt-5-mini";

            function uniq(arr) {
              return [...new Set(arr.filter(Boolean))];
            }

            function collectImageUrls(text) {
              const urls = [];

              // Markdown images: ![alt](url "title")
              const mdRe = /!\[[^\]]*\]\(([^)\s]+)(?:\s+"[^"]*")?\)/g;
              for (const m of text.matchAll(mdRe)) urls.push(m[1]);

              // HTML <img src="...">
              const imgRe = /<img\b[^>]*\bsrc=["']([^"']+)["'][^>]*>/gi;
              for (const m of text.matchAll(imgRe)) urls.push(m[1]);

              // Bare URLs (common GitHub image hosts)
              const bareLineRe = /(^|\n)\s*(https?:\/\/(?:private-user-images\.githubusercontent\.com|user-images\.githubusercontent\.com|github\.com\/user-attachments\/assets)\/[^\s<>()]+)\s*(?=\n|$)/gi;
              for (const m of text.matchAll(bareLineRe)) urls.push(m[2]);

              return uniq(urls);
            }

            function thumbBlock(url, idx) {
  const safeUrl = String(url).replace(/"/g, "&quot;");
  const n = String(idx + 1).padStart(2, "0");

  // GitHub側で“別タブに飛ぶ”のを避けたいので、
  // <details>/<summary>で同ページ内の拡大表示にする
  return [
    `<!-- _NL_THUMBIFIED_${n} -->`,
    `<details>`,
    `<summary><b>画像${n}</b>（クリックで拡大／もう一度で閉じる）<br><img data-nl-thumb="1" src="${safeUrl}" width="360" alt="image ${n} thumb" /></summary>`,
    `<img data-nl-thumb="1" src="${safeUrl}" alt="image ${n} full" />`,
    `</details>`
  ].join("\n");
}
            function thumbifyIssueBody(text) {
              if (!text) return { text, changed: false };

              let out = text;

              // 1) Markdown images -> thumb block
              out = out.replace(/!\[[^\]]*\]\(([^)\s]+)(?:\s+"[^"]*")?\)/g, (m, url) => {
                // skip if already thumbified nearby (best-effort)
                if (m.includes("NL_THUMBIFIED")) return m;
                return `\n${thumbBlock(url, 0)}\n`; // temp idx; will re-index later
              });

              // 2) HTML <img> (not ours) -> thumb block
              out = out.replace(/<img\b([^>]*?)\bsrc=["']([^"']+)["']([^>]*?)>/gi, (m, pre, url, post) => {
                if (m.includes('data-nl-thumb="1"')) return m; // ours
                return `\n${thumbBlock(url, 0)}\n`;
              });

              // 3) Bare image URLs on their own line -> thumb block
              out = out.replace(/(^|\n)\s*(https?:\/\/(?:private-user-images\.githubusercontent\.com|user-images\.githubusercontent\.com|github\.com\/user-attachments\/assets)\/[^\s<>()]+)\s*(?=\n|$)/gi, (m, head, url) => {
                return `${head}\n${thumbBlock(url, 0)}\n`;
              });

              // If nothing inserted, done
              if (!out.includes("NL_THUMBIFIED:")) {
                return { text, changed: false };
              }

              // Re-index all thumbified blocks in order (so 01,02,03...)
              const urls = collectImageUrls(out);
              let idx = 0;
              out = out.replace(/<!-- NL_THUMBIFIED:\d+ -->[\s\S]*?<\/div>/g, () => {
                const url = urls[idx] || "";
                const block = thumbBlock(url, idx);
                idx += 1;
                return block;
              });

              // Add marker to avoid pointless loops
              if (!out.includes("<!-- NL_BODY_THUMBIFIED -->")) {
                out = `<!-- NL_BODY_THUMBIFIED -->\n` + out;
              }

              return { text: out, changed: out !== text };
            }

            async function updateIssueBodyIfNeeded() {
              const rawBody = issue.body || "";
              const { text: newBody, changed } = thumbifyIssueBody(rawBody);
              if (!changed) return { changed: false, error: null };

              try {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: newBody
                });
                return { changed: true, error: null };
              } catch (e) {
                return { changed: false, error: String(e?.message || e) };
              }
            }

            // ---- If "edited" and body changed: only thumbify body, do NOT post a new bot reply ----
            if (action === "edited") {
              const hasBodyChange = !!(context.payload.changes && context.payload.changes.body);
              if (!hasBodyChange) return;

              await updateIssueBodyIfNeeded();
              return;
            }

            // ---- opened / reopened ----
            const bodyUpdate = await updateIssueBodyIfNeeded();

            const rawBody = issue.body || "";
            const imageUrls = collectImageUrls(rawBody).slice(0, 6); // limit

            // Build prompt for AI (keep it simple, Japanese)
            const promptText = [
              "あなたはGitHub Issueを整理するアシスタントです。",
              "目的：依頼内容が空でもエラーにせず、次の1アクションだけ提案する。",
              "条件：",
              "- 専門用語は避ける（必要なら短い説明を添える）",
              "- 返信は日本語",
              "- 画像がある場合：本文の画像はサムネ化済み前提で、確認ポイントを短く聞く",
              "- 依頼が空（No response等）の場合：『どこを見ればいいか（画面のどの部分か）』を1つだけ質問する",
              "",
              "出力は以下の見出しだけ：",
              "要旨 / 次の1アクション（1つだけ） / 手順（Step 1→） / うまくいかない時 / 注意点",
              "",
              "Issue本文：",
              rawBody
            ].join("\n");

            // Call OpenAI Responses API
            if (!apiKey) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: [
                  "Bot側でAI呼び出しに失敗しました。",
                  "",
                  "（内部エラー）OPENAI_API_KEY is missing (Secrets 未設定)",
                  "",
                  "※ APIキー本体は貼らないでください。"
                ].join("\n")
              });
              return;
            }

            const inputContent = [{ type: "input_text", text: promptText }];
            for (const url of imageUrls) {
              inputContent.push({ type: "input_image", image_url: url });
            }

            let aiText = "";
            let aiErr = "";

            try {
              const res = await fetch("https://api.openai.com/v1/responses", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "Authorization": `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                  model,
                  input: [{ role: "user", content: inputContent }],
                  temperature: 0.2
                })
              });

              const data = await res.json();
              if (!res.ok) {
                aiErr = `OpenAI API error: ${res.status} ${res.statusText}\n` + JSON.stringify(data, null, 2);
              } else {
                aiText = (data.output_text || "").trim();
                if (!aiText) aiText = "（空の応答でした）";
              }
            } catch (e) {
              aiErr = String(e?.message || e);
            }

            // Build image preview (thumbnail + details)
            function buildPreview(urls) {
              if (!urls.length) return "";
              const blocks = urls.map((u, i) => thumbBlock(u, i)).join("\n\n");
              return [
                "",
                "---",
                "## 添付画像（プレビュー）",
                blocks
              ].join("\n");
            }

            const bodyStatusLine = bodyUpdate.error
              ? `本文サムネ化：NG（${bodyUpdate.error}）`
              : (bodyUpdate.changed ? "本文サムネ化：OK" : "本文サムネ化：変更なし");

            const commentBody = aiErr
              ? [
                  "Bot側でAI呼び出しに失敗しました。",
                  "",
                  "```",
                  aiErr,
                  "```",
                  "",
                  `- ${bodyStatusLine}`,
                  "",
                  "承認して次へ進めるときは、コメント欄に `/approve` と書いてください。",
                  buildPreview(imageUrls)
                ].join("\n")
              : [
                  "## Bot返信（TASK）",
                  "",
                  aiText,
                  "",
                  `- ${bodyStatusLine}`,
                  "",
                  "承認して次へ進めるときは、コメント欄に `/approve` と書いてください。",
                  buildPreview(imageUrls)
                ].join("\n");

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: commentBody
            });
