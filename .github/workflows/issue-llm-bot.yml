name: Issue LLM Bot

on:
  issues:
    types: [opened]

permissions:
  issues: write

jobs:
  reply:
    # ã‚¿ã‚¤ãƒˆãƒ«ãŒ [TASK] ã§å§‹ã¾ã‚‹Issueã ã‘åå¿œ
    if: startsWith(github.event.issue.title, '[TASK]')
    runs-on: ubuntu-latest
    steps:
      - name: Generate reply (OpenAI -> fallback Gemini)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          set -e
          python3 - <<'PY'
import os, json, urllib.request

title = os.environ.get("ISSUE_TITLE","").strip()
body  = os.environ.get("ISSUE_BODY","").strip()

prompt = f"""ã‚ãªãŸã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè£œåŠ©AIã§ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã€Œã‚³ãƒ”ãƒšä¿‚ã€ã‚’æ¸›ã‚‰ã—ãŸã„ã®ã§ã€å›žç­”ã¯çŸ­ããƒ»å®Ÿè¡Œã—ã‚„ã™ãã€‚

ä»¥ä¸‹ã®Issueå†…å®¹ã‹ã‚‰ã€æ¬¡ã‚’æ—¥æœ¬èªžMarkdownã§è¿”ã—ã¦ãã ã•ã„ï¼š
1) è¦æ—¨ï¼ˆ1ï½ž2è¡Œï¼‰
2) æ¬¡ã®1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆå…·ä½“çš„ãªã‚¯ãƒªãƒƒã‚¯/å…¥åŠ›ã¾ã§ï¼‰
3) ã†ã¾ãã„ã‹ãªã„æ™‚ã®åˆ†å²ï¼ˆA/Bã®2ã¤ã¾ã§ï¼‰
4) æ³¨æ„ç‚¹ï¼ˆç§˜å¯†æƒ…å ±ã‚’è²¼ã‚‰ãªã„ç­‰ã€1ï½ž2è¡Œï¼‰

--- Issue Title ---
{title}

--- Issue Body ---
{body}
"""

def http_json(url, headers, payload):
  data = json.dumps(payload).encode("utf-8")
  req = urllib.request.Request(url, data=data, headers=headers, method="POST")
  with urllib.request.urlopen(req, timeout=60) as r:
    return r.getcode(), json.loads(r.read().decode("utf-8"))

def try_openai():
  # ãƒ¢ãƒ‡ãƒ«åã¯ç’°å¢ƒã«ã‚ˆã‚Šé•ã†ã®ã§ã€ã¾ãšã¯è»½é‡ãƒ¢ãƒ‡ãƒ«æƒ³å®šã€‚
  # ã†ã¾ãã„ã‹ãªã‘ã‚Œã°è‡ªå‹•ã§Geminiã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™ã€‚
  model_candidates = ["gpt-4o-mini", "gpt-4.1-mini", "gpt-4o", "gpt-4.1"]
  for model in model_candidates:
    try:
      code, d = http_json(
        "https://api.openai.com/v1/responses",
        {
          "Content-Type": "application/json",
          "Authorization": f"Bearer {os.environ.get('OPENAI_API_KEY','')}",
        },
        {"model": model, "input": prompt, "max_output_tokens": 400},
      )
      if isinstance(d, dict) and "error" in d:
        continue
      # output_text ãŒã‚ã‚Œã°å„ªå…ˆ
      text = d.get("output_text","").strip()
      if not text:
        # å¿µã®ãŸã‚æ—§å½¢å¼ã‚‚æ‹¾ã†
        try:
          for part in d["output"][0]["content"]:
            if isinstance(part, dict) and "text" in part:
              text += part["text"]
        except Exception:
          pass
      text = (text or "").strip()
      if text:
        return text, model
    except Exception:
      continue
  return None, None

def try_gemini():
  model = "gemini-2.5-flash"
  url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={os.environ.get('GEMINI_API_KEY','')}"
  payload = {"contents":[{"parts":[{"text": prompt}]}]}
  code, d = http_json(url, {"Content-Type":"application/json"}, payload)
  if isinstance(d, dict) and "error" in d:
    raise RuntimeError(str(d["error"]))
  text = ""
  try:
    text = d["candidates"][0]["content"]["parts"][0]["text"]
  except Exception:
    text = json.dumps(d)[:500]
  return (text or "").strip(), model

text, used = try_openai()
src = ""
if text:
  src = f"OpenAI({used})"
else:
  text, used = try_gemini()
  src = f"Gemini({used})"

out = f"""### ðŸ¤– è‡ªå‹•è¿”ä¿¡ï¼ˆ{src}ï¼‰

{text}
"""
with open("comment.md","w",encoding="utf-8") as f:
  f.write(out)
print("Generated comment.md")
PY

      - name: Post comment to issue
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          set -e
          python3 - <<'PY'
import os, json, urllib.request
repo = os.environ["REPO"]
num  = os.environ["ISSUE_NUMBER"]
body = open("comment.md","r",encoding="utf-8").read()

url = f"https://api.github.com/repos/{repo}/issues/{num}/comments"
payload = json.dumps({"body": body}).encode("utf-8")
req = urllib.request.Request(
  url,
  data=payload,
  method="POST",
  headers={
    "Authorization": f"Bearer {os.environ['GH_TOKEN']}",
    "Accept": "application/vnd.github+json",
    "Content-Type": "application/json",
  },
)
with urllib.request.urlopen(req, timeout=60) as r:
  print("Comment posted:", r.status)
PY
