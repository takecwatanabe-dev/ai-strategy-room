name: Issue LLM Bot

on:
  issues:
    types: [opened, reopened]

permissions:
  issues: write
  contents: read

jobs:
  task_auto_reply:
    if: startsWith(github.event.issue.title, '[TASK]')
    runs-on: ubuntu-latest
    steps:
      - name: Post auto reply (TASK)
        uses: actions/github-script@v7
        env:
          # â˜…ã“ã‚Œã ã‘ã§OKï¼ˆPENAI_* ã¯ä½¿ã‚ãªã„ï¼‰
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_MODEL: gpt-5-mini
          BOT_VERSION: v1.2.1-thumb-details-r2
          # ç”»åƒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç”¨ï¼ˆprivate-user-images å¯¾ç­–ï¼‰
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const issue = context.payload.issue;
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // ---------- time helpers (JST) ----------
            function jstNow() {
              const dt = new Date();
              const fmt = new Intl.DateTimeFormat("ja-JP", {
                timeZone: "Asia/Tokyo",
                year: "numeric", month: "2-digit", day: "2-digit",
                hour: "2-digit", minute: "2-digit", second: "2-digit",
                hour12: false,
              });
              const parts = Object.fromEntries(fmt.formatToParts(dt).map(p => [p.type, p.value]));
              return `${parts.year}-${parts.month}-${parts.day} ${parts.hour}:${parts.minute}:${parts.second} JST`;
            }

            // ---------- image extraction ----------
            function extractImageUrls(text) {
              const urls = new Set();
              if (!text) return [];
              // Markdown: ![alt](url)
              const md = /!\[[^\]]*\]\(([^)\s]+)(?:\s+"[^"]*")?\)/g;
              // HTML: <img src="...">
              const html = /<img(?![^>]*data-aisr=)[^>]*\s+src=["']([^"']+)["'][^>]*>/gi;

              let m;
              while ((m = md.exec(text)) !== null) urls.add(m[1]);
              while ((m = html.exec(text)) !== null) urls.add(m[1]);

              return Array.from(urls);
            }

            // ---------- thumbnail + details block (GitHub markdown with HTML) ----------
            function thumbDetailsBlock(url) {
              const safe = String(url).replace(/"/g, "&quot;");
              return [
                `<img data-aisr="thumb" src="${safe}" width="320" alt="thumb">`,
                `<details>`,
                `<summary>ğŸ–¼ å¤§ãã‚è¡¨ç¤ºï¼ˆã‚¯ãƒªãƒƒã‚¯ã§é–‹ãï¼é–‰ã˜ã‚‹ï¼‰</summary>`,
                ``,
                `<img data-aisr="full" src="${safe}" alt="full">`,
                `</details>`
              ].join("\n");
            }

            // Issueæœ¬æ–‡ã®ã€Œãƒ‡ã‚«ã„ç”»åƒã€ã‚’è‡ªå‹•ã§ã‚µãƒ ãƒåŒ–ï¼ˆæ–‡å­—ãŒèª­ã¿ã‚„ã™ããªã‚‹ï¼‰
            function normalizeBodyImages(body) {
              if (!body) return body;

              // Markdown image -> thumb+details
              body = body.replace(/!\[[^\]]*\]\(([^)\s]+)(?:\s+"[^"]*")?\)/g, (all, url) => {
                return thumbDetailsBlock(url);
              });

              // HTML img (data-aisr ãŒç„¡ã„ã‚‚ã®ã ã‘) -> thumb+details
              body = body.replace(/<img(?![^>]*data-aisr=)[^>]*\s+src=["']([^"']+)["'][^>]*>/gi, (all, url) => {
                return thumbDetailsBlock(url);
              });

              return body;
            }

            // ---------- OpenAI helpers ----------
            function extractOutputText(data) {
              if (!data) return "";
              if (typeof data.output_text === "string" && data.output_text.trim()) return data.output_text.trim(); // docs: output_text :contentReference[oaicite:1]{index=1}
              try {
                const parts = [];
                for (const item of (data.output || [])) {
                  for (const c of (item.content || [])) {
                    if (c.type === "output_text" && c.text) parts.push(c.text);
                  }
                }
                return parts.join("\n").trim();
              } catch {
                return "";
              }
            }

            async function toDataUrl(url) {
              const headers = {
                "User-Agent": "ai-strategy-room-bot",
                "Accept": "image/*",
              };
              const ghToken = process.env.GITHUB_TOKEN;
              if (ghToken) headers["Authorization"] = `token ${ghToken}`;

              const res = await fetch(url, { headers, redirect: "follow" });
              if (!res.ok) throw new Error(`image fetch failed: ${res.status}`);

              const mime = (res.headers.get("content-type") || "image/png").split(";")[0].trim();
              const buf = Buffer.from(await res.arrayBuffer());

              // å¤§ãã™ãã‚‹ç”»åƒã¯ç„¡ç†ã« data URL åŒ–ã—ãªã„ï¼ˆOpenAIé€ä¿¡ã‚µã‚¤ã‚ºå¯¾ç­–ï¼‰
              if (buf.length > 4_500_000) throw new Error("image too large for data url");

              // data URL ã¯å…¬å¼ã«OK :contentReference[oaicite:2]{index=2}
              return `data:${mime};base64,${buf.toString("base64")}`;
            }

            async function callOpenAI({ promptText, imageUrls }) {
              const apiKey = process.env.OPENAI_API_KEY;
              if (!apiKey) return { ok: false, error: "OPENAI_API_KEY ãŒæœªè¨­å®šã§ã™ï¼ˆSecrets ã‚’ç¢ºèªï¼‰" };

              const model = process.env.OPENAI_MODEL || "gpt-4.1-mini";
              const content = [{ type: "input_text", text: promptText }]; // â˜… text ã§ã¯ãªã input_text :contentReference[oaicite:3]{index=3}

              // æœ€å¤§4æšã¾ã§
              for (const url of (imageUrls || []).slice(0, 4)) {
                try {
                  const dataUrl = await toDataUrl(url);
                  content.push({ type: "input_image", image_url: dataUrl }); // â˜… input_image :contentReference[oaicite:4]{index=4}
                } catch {
                  // data URL åŒ–ã§ããªã„æ™‚ã¯ URL ã®ã¾ã¾ï¼ˆå–ã‚Œã‚Œã°OKï¼‰
                  content.push({ type: "input_image", image_url: url });
                }
              }

              const payload = {
                model,
                input: [
                  {
                    role: "user",
                    content
                  }
                ]
              };

              const r = await fetch("https://api.openai.com/v1/responses", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "Authorization": `Bearer ${apiKey}`
                },
                body: JSON.stringify(payload)
              });

              const raw = await r.text();
              if (!r.ok) return { ok: false, error: `OpenAI API error: ${r.status}\n${raw}` };

              let data;
              try { data = JSON.parse(raw); } catch { return { ok: false, error: "OpenAIå¿œç­”ã®JSONè§£æã«å¤±æ•—ã—ã¾ã—ãŸ" }; }

              const text = extractOutputText(data);
              return { ok: true, text: text || "(AIã®å‡ºåŠ›ãŒç©ºã§ã—ãŸ)" };
            }

            // ---------- main ----------
            const originalBody = issue.body || "";
            const imageUrls = extractImageUrls(originalBody);

            // 1) Issueæœ¬æ–‡ã®å·¨å¤§ç”»åƒã‚’ã‚µãƒ ãƒåŒ–ï¼ˆèª­ã‚€é‚ªé­”ã‚’æ¶ˆã™ï¼‰
            const normalized = normalizeBodyImages(originalBody);
            if (normalized !== originalBody) {
              await github.rest.issues.update({
                owner, repo,
                issue_number: issue.number,
                body: normalized
              });
            }

            // 2) AIã«æŠ•ã’ã‚‹ï¼ˆç©ºæ¬„ã§ã‚‚â€œã‚¨ãƒ©ãƒ¼â€æ‰±ã„ã«ã—ãªã„ï¼‰
            const promptText =
`ã‚ãªãŸã¯ã€ŒAIæˆ¦ç•¥ä¼šè­°å®¤ã€ã®é‹ç”¨è£œåŠ©ã§ã™ã€‚
æ¬¡ã®Issueå†…å®¹ã‚’èª­ã¿ã€çŸ­ãæ•´ç†ã—ã¦è¿”ã—ã¦ãã ã•ã„ã€‚

# å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆã“ã®é †ç•ªï¼‰
- è¦æ—¨ï¼ˆ1ã€œ2è¡Œï¼‰
- æ¬¡ã®1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆ1ã¤ã ã‘ï¼‰
- æ³¨æ„ç‚¹ï¼ˆã‚ã‚Œã°ï¼‰

# ãƒ«ãƒ¼ãƒ«
- Secretsåã¯ OPENAI_API_KEY ä»¥å¤–ã‚’æ›¸ã‹ãªã„ï¼ˆPENAI_* ãªã©ä¸€åˆ‡ç¦æ­¢ï¼‰
- Issueæœ¬æ–‡ã® "No response" ã¯æœªè¨˜å…¥ã¨ã—ã¦æ‰±ã†ï¼ˆã‚¨ãƒ©ãƒ¼æ‰±ã„ã—ãªã„ï¼‰
- ç”»åƒãŒã‚ã‚‹å ´åˆã¯ã€Œç”»åƒã®ã©ã“ã‚’è¦‹ã‚‹ã¹ãã‹ã€ã‚’1è¡Œæ·»ãˆã‚‹

# Issue
ã‚¿ã‚¤ãƒˆãƒ«: ${issue.title}
æœ¬æ–‡:
${originalBody}`.trim();

            const build = jstNow();
            const botVer = process.env.BOT_VERSION || "unknown";

            const ai = await callOpenAI({ promptText, imageUrls });

            // 3) ã‚³ãƒ¡ãƒ³ãƒˆçµ„ã¿ç«‹ã¦ï¼ˆã‚µãƒ ãƒã¯æŠ˜ã‚ŠãŸãŸã¿å‰ã‹ã‚‰è¦‹ãˆã‚‹ï¼‰
            let comment = "";
            comment += `Botè¿”ä¿¡ï¼ˆTASKï¼‰\n\n`;
            comment += `- build: ${build}\n`;
            comment += `- version: ${botVer}\n\n`;

            if (!ai.ok) {
              comment += `## è¦æ—¨\nBotå´ã§AIå‘¼ã³å‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n\n`;
              comment += `## æ¬¡ã®1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆ1ã¤ã ã‘ï¼‰\nActions ã®å®Ÿè¡Œãƒ­ã‚°ã§ã€ã„ã¡ã°ã‚“ä¸‹ã®èµ¤ã„ã‚¨ãƒ©ãƒ¼è¡Œã‚’ã“ã®Issueã«è²¼ã£ã¦ãã ã•ã„ã€‚\n\n`;
              comment += `## æ³¨æ„ç‚¹\n- APIã‚­ãƒ¼æœ¬ä½“ã¯è²¼ã‚‰ãªã„ã§ãã ã•ã„\n- Secrets ã¯ **OPENAI_API_KEY** ã®ã¿ç¢ºèªã—ã¦ãã ã•ã„\n\n`;
              comment += `\n<details><summary>ï¼ˆå†…éƒ¨ã‚¨ãƒ©ãƒ¼è¦ç´„ï¼‰</summary>\n\n\`\`\`\n${ai.error}\n\`\`\`\n</details>\n`;
            } else {
              comment += `${ai.text}\n\n`;
              comment += `---\n\næ‰¿èªã—ã¦æ¬¡ã¸é€²ã‚ã‚‹ã¨ãã¯ã€ã‚³ãƒ¡ãƒ³ãƒˆæ¬„ã« **/approve** ã¨æ›¸ã„ã¦ãã ã•ã„ã€‚\n`;
            }

            if (imageUrls.length) {
              comment += `\n---\n\n## æ·»ä»˜ç”»åƒï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰\n`;
              for (const url of imageUrls.slice(0, 8)) {
                comment += `\n${thumbDetailsBlock(url)}\n`;
              }
            }

            await github.rest.issues.createComment({
              owner, repo,
              issue_number: issue.number,
              body: comment
            });
