# .github/workflows/issue-llm-bot.yml
name: Issue LLM Bot

on:
  issues:
    types: [opened, reopened]

permissions:
  issues: write
  contents: read

jobs:
  reply:
    runs-on: ubuntu-latest

    steps:
      - name: Build bot reply and post/update comment
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_MODEL: ${{ vars.OPENAI_MODEL || 'gpt-4o-mini' }}
        with:
          script: |
            /**
             * Issue LLM Bot v0.3.0
             * Build(JST): 2025-12-14 11:44
             * Output: è¦æ—¨ / æ¬¡ã®1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ / åˆ†å² / æ³¨æ„ + æ·»ä»˜ç”»åƒï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰
             * Note: GitHubä¸Šã®ç”»åƒUIã¯åˆ¶ç´„ã‚ã‚Š â†’ <details>ã§ã€Œé–‹é–‰ã€ã‚’æä¾›
             */

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.issue.number;

            const marker = "<!-- ISSUE_LLM_BOT -->";

            function extractImageUrls(text) {
              if (!text) return [];
              const urls = new Set();

              // Markdown: ![alt](url)
              const mdImg = /!\[[^\]]*\]\((https?:\/\/[^\s)]+)\)/g;
              let m;
              while ((m = mdImg.exec(text)) !== null) urls.add(m[1]);

              // HTML: <img src="...">
              const htmlImg = /<img[^>]+src=["'](https?:\/\/[^"']+)["'][^>]*>/g;
              while ((m = htmlImg.exec(text)) !== null) urls.add(m[1]);

              // Fallback: direct github user-attachments/assets links
              const assets = /(https?:\/\/github\.com\/user-attachments\/assets\/[a-zA-Z0-9\-]+)/g;
              while ((m = assets.exec(text)) !== null) urls.add(m[1]);

              return Array.from(urls);
            }

            function buildDetailsPreview(urls) {
              if (!urls.length) return "";
              const lines = [];
              lines.push("## æ·»ä»˜ç”»åƒï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰");
              lines.push("");
              lines.push("<details>");
              lines.push("  <summary>ğŸ–¼ æ·»ä»˜ç”»åƒï¼ˆã‚¯ãƒªãƒƒã‚¯ã§é–‹ãï¼ã‚‚ã†ä¸€åº¦ã§é–‰ã˜ã‚‹ï¼‰</summary>");
              lines.push("  <br />");
              urls.slice(0, 8).forEach((u, i) => {
                const n = i + 1;
                // â€œå¹…ã‚’æ•´ãˆã‚‹â€ï¼šthumbã¯å›ºå®šå¹…ã€fullã¯å¤§ãã‚ï¼ˆGitHubå´ã®è¡¨ç¤ºã«ä»»ã›ã‚‹ï¼‰
                lines.push(`  <p><strong>#${n}</strong></p>`);
                lines.push(`  <p><img src="${u}" width="520" alt="thumb-${n}" /></p>`);
                lines.push(`  <p><img src="${u}" width="860" alt="full-${n}" /></p>`);
                lines.push("  <hr />");
              });
              if (urls.length > 8) {
                lines.push(`  <p>ï¼ˆã»ã‹ ${urls.length - 8} æšã¯çœç•¥ï¼‰</p>`);
              }
              lines.push("</details>");
              lines.push("");
              lines.push("â€» GitHubã®ä»•æ§˜ã§ã€ç”»åƒã‚¯ãƒªãƒƒã‚¯æ™‚ã®æŒ™å‹•ï¼ˆåˆ¥è¡¨ç¤ºãªã©ï¼‰ã¯å®Œå…¨ã«ã¯åˆ¶å¾¡ã§ãã¾ã›ã‚“ã€‚");
              return lines.join("\n");
            }

            // 1) Read issue
            const issueRes = await github.rest.issues.get({
              owner, repo, issue_number
            });

            const issue = issueRes.data;
            const title = issue.title || "";
            const body = issue.body || "";

            // 2) Collect image urls from issue body (commentsã¾ã§æ‹¾ã†ãªã‚‰ã“ã“ã§è¿½åŠ APIã‚’å‘¼ã¶)
            const imageUrls = extractImageUrls(body);

            // 3) Call OpenAI for summary/next action
            const apiKey = process.env.OPENAI_API_KEY;
            if (!apiKey) {
              core.setFailed("OPENAI_API_KEY is not set in repository secrets.");
              return;
            }
            const model = process.env.OPENAI_MODEL || "gpt-4o-mini";

            const prompt = `
ã‚ãªãŸã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆé‹ç”¨ãƒœãƒƒãƒˆã§ã™ã€‚
ä»¥ä¸‹ã®Issueã‚’èª­ã‚“ã§ã€æ—¥æœ¬èªã§ã€Œè¦æ—¨ã€ã€Œæ¬¡ã®1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã€ã€Œã†ã¾ãã„ã‹ãªã„æ™‚ã®åˆ†å²ã€ã€Œæ³¨æ„ç‚¹ã€ã‚’çŸ­ãå‡ºã—ã¦ãã ã•ã„ã€‚
- æ¬¡ã®1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯å¿…ãš1ã¤ã ã‘ï¼ˆå…·ä½“çš„ã«ï¼‰
- ä½™è¨ˆãªå‰ç½®ããªã—
- Markdownã§å‡ºåŠ›

[Issue Title]
${title}

[Issue Body]
${body}
`.trim();

            const openaiRes = await fetch("https://api.openai.com/v1/chat/completions", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${apiKey}`
              },
              body: JSON.stringify({
                model,
                temperature: 0.2,
                messages: [
                  { role: "system", content: "å‡ºåŠ›ã¯å¿…ãšæ—¥æœ¬èªã€‚çŸ­ãã€å®Ÿå‹™çš„ã«ã€‚" },
                  { role: "user", content: prompt }
                ]
              })
            });

            if (!openaiRes.ok) {
              const t = await openaiRes.text();
              core.setFailed(`OpenAI API error: ${openaiRes.status} ${t}`);
              return;
            }

            const openaiJson = await openaiRes.json();
            const aiText = (openaiJson.choices?.[0]?.message?.content || "").trim();

            // 4) Build final comment
            const previewBlock = buildDetailsPreview(imageUrls);
            const finalBody = [
              marker,
              "bot: OpenAI",
              "",
              aiText,
              "",
              previewBlock
            ].filter(Boolean).join("\n");

            // 5) Update existing bot comment if exists, else create new
            const commentsRes = await github.rest.issues.listComments({
              owner, repo, issue_number, per_page: 100
            });

            const existing = commentsRes.data.find(c => (c.body || "").includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({
                owner, repo,
                comment_id: existing.id,
                body: finalBody
              });
            } else {
              await github.rest.issues.createComment({
                owner, repo, issue_number,
                body: finalBody
              });
            }
